/* tslint:disable */
/* eslint-disable */
/**
 * Weblens API
 * Programmatic access to the Weblens server
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiKeyInfo
 */
export interface ApiKeyInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'createdBy'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyInfo
     */
    'createdTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'remoteUsing'?: string;
}
/**
 * 
 * @export
 * @interface CreateFolderBody
 */
export interface CreateFolderBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateFolderBody
     */
    'children'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateFolderBody
     */
    'newFolderName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFolderBody
     */
    'parentFolderId': string;
}
/**
 * 
 * @export
 * @interface FileInfo
 */
export interface FileInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof FileInfo
     */
    'childrenIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'contentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileInfo
     */
    'isDir'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FileInfo
     */
    'modifiable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FileInfo
     */
    'modifyTimestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'parentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'portablePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'shareId'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileInfo
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface FileShare
 */
export interface FileShare {
    /**
     * 
     * @type {Array<string>}
     * @memberof FileShare
     */
    'accessors'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof FileShare
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FileShare
     */
    'expires'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileShare
     */
    'fileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileShare
     */
    'owner'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileShare
     */
    'public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FileShare
     */
    'shareId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileShare
     */
    'shareName'?: string;
    /**
     * 
     * @type {ModelsShareType}
     * @memberof FileShare
     */
    'shareType'?: ModelsShareType;
    /**
     * 
     * @type {string}
     * @memberof FileShare
     */
    'updated'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileShare
     */
    'wormhole'?: boolean;
}


/**
 * 
 * @export
 * @interface FileTreeFileAction
 */
export interface FileTreeFileAction {
    /**
     * 
     * @type {FileTreeFileActionType}
     * @memberof FileTreeFileAction
     */
    'actionType'?: FileTreeFileActionType;
    /**
     * OriginId        FileId `json:\"originId\" bson:\"originId,omitempty\"`
     * @type {string}
     * @memberof FileTreeFileAction
     */
    'destinationPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileTreeFileAction
     */
    'eventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileTreeFileAction
     */
    'lifeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileTreeFileAction
     */
    'originPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileTreeFileAction
     */
    'parentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileTreeFileAction
     */
    'serverId'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileTreeFileAction
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof FileTreeFileAction
     */
    'timestamp'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FileTreeFileActionType = {
    FileCreate: 'fileCreate',
    FileMove: 'fileMove',
    FileSizeChange: 'fileSizeChange',
    Backup: 'backup',
    FileDelete: 'fileDelete',
    FileRestore: 'fileRestore'
} as const;

export type FileTreeFileActionType = typeof FileTreeFileActionType[keyof typeof FileTreeFileActionType];


/**
 * 
 * @export
 * @interface FilesListParams
 */
export interface FilesListParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof FilesListParams
     */
    'fileIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FolderInfo
 */
export interface FolderInfo {
    /**
     * 
     * @type {Array<FileInfo>}
     * @memberof FolderInfo
     */
    'children'?: Array<FileInfo>;
    /**
     * 
     * @type {Array<MediaInfo>}
     * @memberof FolderInfo
     */
    'medias'?: Array<MediaInfo>;
    /**
     * 
     * @type {Array<FileInfo>}
     * @memberof FolderInfo
     */
    'parents'?: Array<FileInfo>;
    /**
     * 
     * @type {FileInfo}
     * @memberof FolderInfo
     */
    'self'?: FileInfo;
}
/**
 * 
 * @export
 * @interface LoginBody
 */
export interface LoginBody {
    /**
     * 
     * @type {string}
     * @memberof LoginBody
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginBody
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface MediaBatchInfo
 */
export interface MediaBatchInfo {
    /**
     * 
     * @type {Array<MediaInfo>}
     * @memberof MediaBatchInfo
     */
    'Media'?: Array<MediaInfo>;
    /**
     * 
     * @type {number}
     * @memberof MediaBatchInfo
     */
    'mediaCount'?: number;
}
/**
 * 
 * @export
 * @interface MediaIdsParams
 */
export interface MediaIdsParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaIdsParams
     */
    'mediaIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MediaInfo
 */
export interface MediaInfo {
    /**
     * Hash of the file content, to ensure that the same files don\'t get duplicated
     * @type {string}
     * @memberof MediaInfo
     */
    'contentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaInfo
     */
    'createDate'?: string;
    /**
     * Total time, in milliseconds, of a video
     * @type {number}
     * @memberof MediaInfo
     */
    'duration'?: number;
    /**
     * If the media disabled. This can happen when the backing file(s) are deleted, but the media stays behind because it can be re-used if needed.
     * @type {boolean}
     * @memberof MediaInfo
     */
    'enabled'?: boolean;
    /**
     * Slices of files whos content hash to the contentId
     * @type {Array<string>}
     * @memberof MediaInfo
     */
    'fileIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MediaInfo
     */
    'height'?: number;
    /**
     * If the media is hidden from the timeline TODO - make this per user
     * @type {boolean}
     * @memberof MediaInfo
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaInfo
     */
    'likedBy'?: Array<string>;
    /**
     * Mime-type key of the media
     * @type {string}
     * @memberof MediaInfo
     */
    'mimeType'?: string;
    /**
     * User who owns the file that resulted in this media being created
     * @type {string}
     * @memberof MediaInfo
     */
    'owner'?: string;
    /**
     * Number of pages (typically 1, 0 in not a valid page count)
     * @type {number}
     * @memberof MediaInfo
     */
    'pageCount'?: number;
    /**
     * Tags from the ML image scan so searching for particular objects in the images can be done
     * @type {Array<string>}
     * @memberof MediaInfo
     */
    'recognitionTags'?: Array<string>;
    /**
     * The rotation of the image from its original. Found from the exif data
     * @type {string}
     * @memberof MediaInfo
     */
    'rotate'?: string;
    /**
     * Full-res image dimensions
     * @type {number}
     * @memberof MediaInfo
     */
    'width'?: number;
}
/**
 * 
 * @export
 * @interface MediaType
 */
export interface MediaType {
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaType
     */
    'FileExtension'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MediaType
     */
    'FriendlyName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MediaType
     */
    'IsDisplayable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaType
     */
    'IsRaw'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaType
     */
    'IsVideo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaType
     */
    'MultiPage'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaType
     */
    'RawThumbExifKey'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MediaType
     */
    'SupportsImgRecog'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaType
     */
    'mime'?: string;
}
/**
 * 
 * @export
 * @interface MediaTypeInfo
 */
export interface MediaTypeInfo {
    /**
     * 
     * @type {{ [key: string]: MediaType; }}
     * @memberof MediaTypeInfo
     */
    'extMap'?: { [key: string]: MediaType; };
    /**
     * 
     * @type {{ [key: string]: MediaType; }}
     * @memberof MediaTypeInfo
     */
    'mimeMap'?: { [key: string]: MediaType; };
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ModelsServerRole = {
    InitServerRole: 'init',
    CoreServerRole: 'core',
    BackupServerRole: 'backup',
    RestoreServerRole: 'restore'
} as const;

export type ModelsServerRole = typeof ModelsServerRole[keyof typeof ModelsServerRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const ModelsShareType = {
    SharedFile: 'file',
    SharedAlbum: 'album'
} as const;

export type ModelsShareType = typeof ModelsShareType[keyof typeof ModelsShareType];


/**
 * 
 * @export
 * @interface MoveFilesParams
 */
export interface MoveFilesParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof MoveFilesParams
     */
    'fileIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MoveFilesParams
     */
    'newParentId'?: string;
}
/**
 * 
 * @export
 * @interface NewServerParams
 */
export interface NewServerParams {
    /**
     * 
     * @type {string}
     * @memberof NewServerParams
     */
    'name'?: string;
    /**
     * 
     * @type {ModelsServerRole}
     * @memberof NewServerParams
     */
    'role'?: ModelsServerRole;
    /**
     * 
     * @type {string}
     * @memberof NewServerParams
     */
    'serverId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewServerParams
     */
    'usingKey'?: string;
}


/**
 * 
 * @export
 * @interface NewUserParams
 */
export interface NewUserParams {
    /**
     * 
     * @type {boolean}
     * @memberof NewUserParams
     */
    'admin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewUserParams
     */
    'autoActivate': boolean;
    /**
     * 
     * @type {string}
     * @memberof NewUserParams
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof NewUserParams
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PasswordUpdateParams
 */
export interface PasswordUpdateParams {
    /**
     * 
     * @type {string}
     * @memberof PasswordUpdateParams
     */
    'newPassword': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordUpdateParams
     */
    'oldPassword'?: string;
}
/**
 * 
 * @export
 * @interface RestScanBody
 */
export interface RestScanBody {
    /**
     * 
     * @type {string}
     * @memberof RestScanBody
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestScanBody
     */
    'folderId'?: string;
}
/**
 * 
 * @export
 * @interface RestoreFilesBody
 */
export interface RestoreFilesBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof RestoreFilesBody
     */
    'fileIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RestoreFilesBody
     */
    'newParentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof RestoreFilesBody
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface RestoreFilesInfo
 */
export interface RestoreFilesInfo {
    /**
     * 
     * @type {string}
     * @memberof RestoreFilesInfo
     */
    'newParentId'?: string;
}
/**
 * 
 * @export
 * @interface ServerInfo
 */
export interface ServerInfo {
    /**
     * 
     * @type {number}
     * @memberof ServerInfo
     */
    'backupSize'?: number;
    /**
     * Address of the remote server, only if the instance is a core. Not set for any remotes/backups on core server, as it IS the core
     * @type {string}
     * @memberof ServerInfo
     */
    'coreAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServerInfo
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServerInfo
     */
    'lastBackup'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServerInfo
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServerInfo
     */
    'online'?: boolean;
    /**
     * Role the server is currently reporting. This is used to determine if the server is online (and functional) or not
     * @type {ModelsServerRole}
     * @memberof ServerInfo
     */
    'reportedRole'?: ModelsServerRole;
    /**
     * Core or Backup
     * @type {ModelsServerRole}
     * @memberof ServerInfo
     */
    'role'?: ModelsServerRole;
    /**
     * 
     * @type {boolean}
     * @memberof ServerInfo
     */
    'started'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServerInfo
     */
    'userCount'?: number;
}


/**
 * 
 * @export
 * @interface TakeoutInfo
 */
export interface TakeoutInfo {
    /**
     * 
     * @type {string}
     * @memberof TakeoutInfo
     */
    'filename'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TakeoutInfo
     */
    'single'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TakeoutInfo
     */
    'takeoutId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TakeoutInfo
     */
    'taskId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateFileParams
 */
export interface UpdateFileParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateFileParams
     */
    'newName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFileParams
     */
    'newParentId'?: string;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    'admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'homeId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    'owner'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'trashId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface UserInfoArchive
 */
export interface UserInfoArchive {
    /**
     * 
     * @type {boolean}
     * @memberof UserInfoArchive
     */
    'activated'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfoArchive
     */
    'admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'homeId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfoArchive
     */
    'owner'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'trashId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoArchive
     */
    'username'?: string;
}

/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an api key
         * @param {string} keyId Api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey: async (keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('deleteApiKey', 'keyId', keyId)
            const localVarPath = `/keys/{keyId}`
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all api keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.createApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an api key
         * @param {string} keyId Api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey(keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.deleteApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all api keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKeyInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeys(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.getApiKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyInfo> {
            return localVarFp.createApiKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an api key
         * @param {string} keyId Api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(keyId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApiKey(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all api keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKeyInfo>> {
            return localVarFp.getApiKeys(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * 
     * @summary Create a new api key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public createApiKey(options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).createApiKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an api key
     * @param {string} keyId Api key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteApiKey(keyId: string, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).deleteApiKey(keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all api keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public getApiKeys(options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).getApiKeys(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get path completion suggestions
         * @param {string} searchPath Search path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompletePath: async (searchPath: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchPath' is not null or undefined
            assertParamExists('autocompletePath', 'searchPath', searchPath)
            const localVarPath = `/files/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchPath !== undefined) {
                localVarQueryParameter['searchPath'] = searchPath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
         * @summary Create a zip file
         * @param {FilesListParams} request File Ids
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTakeout: async (request: FilesListParams, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createTakeout', 'request', request)
            const localVarPath = `/takeout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Files \"permanently\"
         * @param {FilesListParams} request Delete files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles: async (request: FilesListParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('deleteFiles', 'request', request)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {boolean} [isTakeout] Is this a takeout file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (fileId: string, shareId?: string, isTakeout?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadFile', 'fileId', fileId)
            const localVarPath = `/files/{fileId}/download`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }

            if (isTakeout !== undefined) {
                localVarQueryParameter['isTakeout'] = isTakeout;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (fileId: string, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFile', 'fileId', fileId)
            const localVarPath = `/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the statistics of a file
         * @param {string} fileId File Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileStats: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileStats', 'fileId', fileId)
            const localVarPath = `/files/{fileId}/stats`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the text of a text file
         * @param {string} fileId File Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileText: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileText', 'fileId', fileId)
            const localVarPath = `/files/{fileId}/text`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get files shared with the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a list of files to a new parent folder
         * @param {MoveFilesParams} request Move files request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFiles: async (request: MoveFilesParams, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('moveFiles', 'request', request)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for files by filename
         * @param {string} search Filename to search for
         * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByFilename: async (search: string, baseFolderId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchByFilename', 'search', search)
            const localVarPath = `/files/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (baseFolderId !== undefined) {
                localVarQueryParameter['baseFolderId'] = baseFolderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a list of files to the trash
         * @param {FilesListParams} request Trash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trashFiles: async (request: FilesListParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('trashFiles', 'request', request)
            const localVarPath = `/files/trash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a list of files out of the trash, restoring them to where they were before
         * @param {FilesListParams} request UnTrash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unTrashFiles: async (request: FilesListParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('unTrashFiles', 'request', request)
            const localVarPath = `/files/untrash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a File
         * @param {string} fileId File Id
         * @param {UpdateFileParams} request Update file request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (fileId: string, request: UpdateFileParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('updateFile', 'fileId', fileId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateFile', 'request', request)
            const localVarPath = `/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get path completion suggestions
         * @param {string} searchPath Search path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompletePath(searchPath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.autocompletePath']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
         * @summary Create a zip file
         * @param {FilesListParams} request File Ids
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTakeout(request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TakeoutInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTakeout(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.createTakeout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Files \"permanently\"
         * @param {FilesListParams} request Delete files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFiles(request: FilesListParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFiles(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.deleteFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {boolean} [isTakeout] Is this a takeout file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(fileId: string, shareId?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(fileId, shareId, isTakeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(fileId, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the statistics of a file
         * @param {string} fileId File Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileStats(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileStats(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFileStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the text of a text file
         * @param {string} fileId File Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileText(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileText(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFileText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get files shared with the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedFiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedFiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getSharedFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move a list of files to a new parent folder
         * @param {MoveFilesParams} request Move files request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFiles(request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveFiles(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.moveFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for files by filename
         * @param {string} search Filename to search for
         * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchByFilename(search: string, baseFolderId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchByFilename(search, baseFolderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.searchByFilename']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move a list of files to the trash
         * @param {FilesListParams} request Trash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trashFiles(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.trashFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move a list of files out of the trash, restoring them to where they were before
         * @param {FilesListParams} request UnTrash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unTrashFiles(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.unTrashFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a File
         * @param {string} fileId File Id
         * @param {UpdateFileParams} request Update file request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(fileId: string, request: UpdateFileParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(fileId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.updateFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get path completion suggestions
         * @param {string} searchPath Search path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompletePath(searchPath: string, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo> {
            return localVarFp.autocompletePath(searchPath, options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
         * @summary Create a zip file
         * @param {FilesListParams} request File Ids
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTakeout(request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TakeoutInfo> {
            return localVarFp.createTakeout(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Files \"permanently\"
         * @param {FilesListParams} request Delete files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles(request: FilesListParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFiles(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {boolean} [isTakeout] Is this a takeout file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(fileId: string, shareId?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.downloadFile(fileId, shareId, isTakeout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about a file
         * @param {string} fileId File Id
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileId: string, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo> {
            return localVarFp.getFile(fileId, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the statistics of a file
         * @param {string} fileId File Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileStats(fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFileStats(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the text of a text file
         * @param {string} fileId File Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileText(fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getFileText(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get files shared with the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedFiles(options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo> {
            return localVarFp.getSharedFiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a list of files to a new parent folder
         * @param {MoveFilesParams} request Move files request body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFiles(request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.moveFiles(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for files by filename
         * @param {string} search Filename to search for
         * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByFilename(search: string, baseFolderId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileInfo>> {
            return localVarFp.searchByFilename(search, baseFolderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a list of files to the trash
         * @param {FilesListParams} request Trash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.trashFiles(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a list of files out of the trash, restoring them to where they were before
         * @param {FilesListParams} request UnTrash files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unTrashFiles(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a File
         * @param {string} fileId File Id
         * @param {UpdateFileParams} request Update file request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(fileId: string, request: UpdateFileParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFile(fileId, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Get path completion suggestions
     * @param {string} searchPath Search path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public autocompletePath(searchPath: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).autocompletePath(searchPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dispatch a task to create a zip file of the given files, or get the id of a previously created zip file if it already exists
     * @summary Create a zip file
     * @param {FilesListParams} request File Ids
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public createTakeout(request: FilesListParams, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).createTakeout(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Files \"permanently\"
     * @param {FilesListParams} request Delete files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFiles(request: FilesListParams, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFiles(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {boolean} [isTakeout] Is this a takeout file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public downloadFile(fileId: string, shareId?: string, isTakeout?: boolean, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).downloadFile(fileId, shareId, isTakeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about a file
     * @param {string} fileId File Id
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(fileId: string, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(fileId, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the statistics of a file
     * @param {string} fileId File Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileStats(fileId: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileStats(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the text of a text file
     * @param {string} fileId File Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileText(fileId: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileText(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get files shared with the logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getSharedFiles(options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getSharedFiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a list of files to a new parent folder
     * @param {MoveFilesParams} request Move files request body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public moveFiles(request: MoveFilesParams, shareId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).moveFiles(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for files by filename
     * @param {string} search Filename to search for
     * @param {string} [baseFolderId] The folder to search in, defaults to the user\&#39;s home folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public searchByFilename(search: string, baseFolderId?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).searchByFilename(search, baseFolderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a list of files to the trash
     * @param {FilesListParams} request Trash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public trashFiles(request: FilesListParams, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).trashFiles(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a list of files out of the trash, restoring them to where they were before
     * @param {FilesListParams} request UnTrash files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public unTrashFiles(request: FilesListParams, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).unTrashFiles(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a File
     * @param {string} fileId File Id
     * @param {UpdateFileParams} request Update file request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public updateFile(fileId: string, request: UpdateFileParams, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).updateFile(fileId, request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesHistoryApi - axios parameter creator
 * @export
 */
export const FilesHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Restore files from some time in the past
         * @param {RestoreFilesBody} request Restore files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFiles: async (request: RestoreFilesBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('restoreFiles', 'request', request)
            const localVarPath = `/files/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesHistoryApi - functional programming interface
 * @export
 */
export const FilesHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Restore files from some time in the past
         * @param {RestoreFilesBody} request Restore files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreFilesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreFiles(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesHistoryApi.restoreFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesHistoryApi - factory interface
 * @export
 */
export const FilesHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesHistoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Restore files from some time in the past
         * @param {RestoreFilesBody} request Restore files request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig): AxiosPromise<RestoreFilesInfo> {
            return localVarFp.restoreFiles(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesHistoryApi - object-oriented interface
 * @export
 * @class FilesHistoryApi
 * @extends {BaseAPI}
 */
export class FilesHistoryApi extends BaseAPI {
    /**
     * 
     * @summary Restore files from some time in the past
     * @param {RestoreFilesBody} request Restore files request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesHistoryApi
     */
    public restoreFiles(request: RestoreFilesBody, options?: RawAxiosRequestConfig) {
        return FilesHistoryApiFp(this.configuration).restoreFiles(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FolderApi - axios parameter creator
 * @export
 */
export const FolderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new folder
         * @param {CreateFolderBody} request New folder body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (request: CreateFolderBody, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createFolder', 'request', request)
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a folder
         * @param {string} folderId Folder Id
         * @param {string} [shareId] Share Id
         * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (folderId: string, shareId?: string, timestamp?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolder', 'folderId', folderId)
            const localVarPath = `/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get actions of a folder at a given time
         * @param {string} fileId File Id
         * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory: async (fileId: string, timestamp: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFolderHistory', 'fileId', fileId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getFolderHistory', 'timestamp', timestamp)
            const localVarPath = `/files/{fileId}/history`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dispatch a folder scan
         * @param {RestScanBody} request Scan parameters
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanFolder: async (request: RestScanBody, shareId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('scanFolder', 'request', request)
            const localVarPath = `/folder/scan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareId !== undefined) {
                localVarQueryParameter['shareId'] = shareId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the cover image of a folder
         * @param {string} folderId Folder Id
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFolderCover: async (folderId: string, mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('setFolderCover', 'folderId', folderId)
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('setFolderCover', 'mediaId', mediaId)
            const localVarPath = `/folder/{folderId}/cover`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mediaId !== undefined) {
                localVarQueryParameter['mediaId'] = mediaId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FolderApi - functional programming interface
 * @export
 */
export const FolderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FolderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new folder
         * @param {CreateFolderBody} request New folder body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.createFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a folder
         * @param {string} folderId Folder Id
         * @param {string} [shareId] Share Id
         * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(folderId, shareId, timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.getFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get actions of a folder at a given time
         * @param {string} fileId File Id
         * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderHistory(fileId: string, timestamp: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileTreeFileAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderHistory(fileId, timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.getFolderHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dispatch a folder scan
         * @param {RestScanBody} request Scan parameters
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanFolder(request: RestScanBody, shareId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanFolder(request, shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.scanFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the cover image of a folder
         * @param {string} folderId Folder Id
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFolderCover(folderId: string, mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFolderCover(folderId, mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderApi.setFolderCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FolderApi - factory interface
 * @export
 */
export const FolderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FolderApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new folder
         * @param {CreateFolderBody} request New folder body
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileInfo> {
            return localVarFp.createFolder(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a folder
         * @param {string} folderId Folder Id
         * @param {string} [shareId] Share Id
         * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig): AxiosPromise<FolderInfo> {
            return localVarFp.getFolder(folderId, shareId, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get actions of a folder at a given time
         * @param {string} fileId File Id
         * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderHistory(fileId: string, timestamp: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileTreeFileAction>> {
            return localVarFp.getFolderHistory(fileId, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dispatch a folder scan
         * @param {RestScanBody} request Scan parameters
         * @param {string} [shareId] Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanFolder(request: RestScanBody, shareId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.scanFolder(request, shareId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the cover image of a folder
         * @param {string} folderId Folder Id
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFolderCover(folderId: string, mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setFolderCover(folderId, mediaId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FolderApi - object-oriented interface
 * @export
 * @class FolderApi
 * @extends {BaseAPI}
 */
export class FolderApi extends BaseAPI {
    /**
     * 
     * @summary Create a new folder
     * @param {CreateFolderBody} request New folder body
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public createFolder(request: CreateFolderBody, shareId?: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).createFolder(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a folder
     * @param {string} folderId Folder Id
     * @param {string} [shareId] Share Id
     * @param {number} [timestamp] Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public getFolder(folderId: string, shareId?: string, timestamp?: number, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).getFolder(folderId, shareId, timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get actions of a folder at a given time
     * @param {string} fileId File Id
     * @param {number} timestamp Past timestamp to view the folder at, in ms since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public getFolderHistory(fileId: string, timestamp: number, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).getFolderHistory(fileId, timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dispatch a folder scan
     * @param {RestScanBody} request Scan parameters
     * @param {string} [shareId] Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public scanFolder(request: RestScanBody, shareId?: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).scanFolder(request, shareId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the cover image of a folder
     * @param {string} folderId Folder Id
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public setFolderCover(folderId: string, mediaId: string, options?: RawAxiosRequestConfig) {
        return FolderApiFp(this.configuration).setFolderCover(folderId, mediaId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get paginated media
         * @param {boolean} [raw] Include raw files
         * @param {boolean} [hidden] Include hidden media
         * @param {GetMediaSortEnum} [sort] Sort by field
         * @param {number} [page] Page of medias to get
         * @param {number} [limit] Number of medias to get
         * @param {string} [folderIds] Search only in given folders
         * @param {string} [mediaIds] Get only media with the provided ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMedia: async (raw?: boolean, hidden?: boolean, sort?: GetMediaSortEnum, page?: number, limit?: number, folderIds?: string, mediaIds?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (hidden !== undefined) {
                localVarQueryParameter['hidden'] = hidden;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (folderIds !== undefined) {
                localVarQueryParameter['folderIds'] = folderIds;
            }

            if (mediaIds !== undefined) {
                localVarQueryParameter['mediaIds'] = mediaIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a media image bytes
         * @param {string} mediaId Media Id
         * @param {string} extension Extension
         * @param {GetMediaImageQualityEnum} quality Image Quality
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaImage: async (mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('getMediaImage', 'mediaId', mediaId)
            // verify required parameter 'extension' is not null or undefined
            assertParamExists('getMediaImage', 'extension', extension)
            // verify required parameter 'quality' is not null or undefined
            assertParamExists('getMediaImage', 'quality', quality)
            const localVarPath = `/media/{mediaId}.{extension}`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)))
                .replace(`{${"extension"}}`, encodeURIComponent(String(extension)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get media info
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfo: async (mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('getMediaInfo', 'mediaId', mediaId)
            const localVarPath = `/media/{mediaId}/info`
                .replace(`{${"mediaId"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get media type dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set media visibility
         * @param {boolean} hidden Set the media visibility
         * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaVisibility: async (hidden: boolean, mediaIds: MediaIdsParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hidden' is not null or undefined
            assertParamExists('setMediaVisibility', 'hidden', hidden)
            // verify required parameter 'mediaIds' is not null or undefined
            assertParamExists('setMediaVisibility', 'mediaIds', mediaIds)
            const localVarPath = `/media/visibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hidden !== undefined) {
                localVarQueryParameter['hidden'] = hidden;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get paginated media
         * @param {boolean} [raw] Include raw files
         * @param {boolean} [hidden] Include hidden media
         * @param {GetMediaSortEnum} [sort] Sort by field
         * @param {number} [page] Page of medias to get
         * @param {number} [limit] Number of medias to get
         * @param {string} [folderIds] Search only in given folders
         * @param {string} [mediaIds] Get only media with the provided ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMedia(raw?: boolean, hidden?: boolean, sort?: GetMediaSortEnum, page?: number, limit?: number, folderIds?: string, mediaIds?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMedia(raw, hidden, sort, page, limit, folderIds, mediaIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMedia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a media image bytes
         * @param {string} mediaId Media Id
         * @param {string} extension Extension
         * @param {GetMediaImageQualityEnum} quality Image Quality
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaImage(mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaImage(mediaId, extension, quality, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get media info
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaInfo(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaInfo(mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get media type dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaTypeInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMediaTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getMediaTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set media visibility
         * @param {boolean} hidden Set the media visibility
         * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMediaVisibility(hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMediaVisibility(hidden, mediaIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.setMediaVisibility']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get paginated media
         * @param {boolean} [raw] Include raw files
         * @param {boolean} [hidden] Include hidden media
         * @param {GetMediaSortEnum} [sort] Sort by field
         * @param {number} [page] Page of medias to get
         * @param {number} [limit] Number of medias to get
         * @param {string} [folderIds] Search only in given folders
         * @param {string} [mediaIds] Get only media with the provided ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMedia(raw?: boolean, hidden?: boolean, sort?: GetMediaSortEnum, page?: number, limit?: number, folderIds?: string, mediaIds?: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaBatchInfo> {
            return localVarFp.getMedia(raw, hidden, sort, page, limit, folderIds, mediaIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a media image bytes
         * @param {string} mediaId Media Id
         * @param {string} extension Extension
         * @param {GetMediaImageQualityEnum} quality Image Quality
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaImage(mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getMediaImage(mediaId, extension, quality, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get media info
         * @param {string} mediaId Media Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfo(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaInfo> {
            return localVarFp.getMediaInfo(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get media type dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaTypes(options?: RawAxiosRequestConfig): AxiosPromise<MediaTypeInfo> {
            return localVarFp.getMediaTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set media visibility
         * @param {boolean} hidden Set the media visibility
         * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMediaVisibility(hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setMediaVisibility(hidden, mediaIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * 
     * @summary Get paginated media
     * @param {boolean} [raw] Include raw files
     * @param {boolean} [hidden] Include hidden media
     * @param {GetMediaSortEnum} [sort] Sort by field
     * @param {number} [page] Page of medias to get
     * @param {number} [limit] Number of medias to get
     * @param {string} [folderIds] Search only in given folders
     * @param {string} [mediaIds] Get only media with the provided ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMedia(raw?: boolean, hidden?: boolean, sort?: GetMediaSortEnum, page?: number, limit?: number, folderIds?: string, mediaIds?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMedia(raw, hidden, sort, page, limit, folderIds, mediaIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a media image bytes
     * @param {string} mediaId Media Id
     * @param {string} extension Extension
     * @param {GetMediaImageQualityEnum} quality Image Quality
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMediaImage(mediaId: string, extension: string, quality: GetMediaImageQualityEnum, page?: number, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaImage(mediaId, extension, quality, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get media info
     * @param {string} mediaId Media Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMediaInfo(mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaInfo(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get media type dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getMediaTypes(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getMediaTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set media visibility
     * @param {boolean} hidden Set the media visibility
     * @param {MediaIdsParams} mediaIds MediaIds to change visibility of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public setMediaVisibility(hidden: boolean, mediaIds: MediaIdsParams, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).setMediaVisibility(hidden, mediaIds, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetMediaSortEnum = {
    CreateDate: 'createDate'
} as const;
export type GetMediaSortEnum = typeof GetMediaSortEnum[keyof typeof GetMediaSortEnum];
/**
 * @export
 */
export const GetMediaImageQualityEnum = {
    Thumbnail: 'thumbnail',
    Fullres: 'fullres'
} as const;
export type GetMediaImageQualityEnum = typeof GetMediaImageQualityEnum[keyof typeof GetMediaImageQualityEnum];


/**
 * ServersApi - axios parameter creator
 * @export
 */
export const ServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new remote
         * @param {NewServerParams} request New Server Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemote: async (request: NewServerParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createRemote', 'request', request)
            const localVarPath = `/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a remote
         * @param {string} serverId Server Id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemote: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('deleteRemote', 'serverId', serverId)
            const localVarPath = `/servers/{serverId}`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all remotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemotes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServersApi - functional programming interface
 * @export
 */
export const ServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new remote
         * @param {NewServerParams} request New Server Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServerInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRemote(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServersApi.createRemote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a remote
         * @param {string} serverId Server Id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRemote(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRemote(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServersApi.deleteRemote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all remotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemotes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServerInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRemotes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServersApi.getRemotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServersApi.getServerInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServersApi - factory interface
 * @export
 */
export const ServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new remote
         * @param {NewServerParams} request New Server Params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemote(request: NewServerParams, options?: RawAxiosRequestConfig): AxiosPromise<Array<ServerInfo>> {
            return localVarFp.createRemote(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a remote
         * @param {string} serverId Server Id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemote(serverId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRemote(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all remotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemotes(options?: RawAxiosRequestConfig): AxiosPromise<Array<ServerInfo>> {
            return localVarFp.getRemotes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: RawAxiosRequestConfig): AxiosPromise<ServerInfo> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServersApi - object-oriented interface
 * @export
 * @class ServersApi
 * @extends {BaseAPI}
 */
export class ServersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new remote
     * @param {NewServerParams} request New Server Params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public createRemote(request: NewServerParams, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).createRemote(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a remote
     * @param {string} serverId Server Id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public deleteRemote(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).deleteRemote(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all remotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public getRemotes(options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).getRemotes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public getServerInfo(options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShareApi - axios parameter creator
 * @export
 */
export const ShareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a file share
         * @param {string} shareId Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileShare: async (shareId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareId' is not null or undefined
            assertParamExists('getFileShare', 'shareId', shareId)
            const localVarPath = `/share/{shareId}`
                .replace(`{${"shareId"}}`, encodeURIComponent(String(shareId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareApi - functional programming interface
 * @export
 */
export const ShareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a file share
         * @param {string} shareId Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileShare(shareId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileShare>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileShare(shareId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShareApi.getFileShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShareApi - factory interface
 * @export
 */
export const ShareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a file share
         * @param {string} shareId Share Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileShare(shareId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileShare> {
            return localVarFp.getFileShare(shareId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareApi - object-oriented interface
 * @export
 * @class ShareApi
 * @extends {BaseAPI}
 */
export class ShareApi extends BaseAPI {
    /**
     * 
     * @summary Get a file share
     * @param {string} shareId Share Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getFileShare(shareId: string, options?: RawAxiosRequestConfig) {
        return ShareApiFp(this.configuration).getFileShare(shareId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update active status of user
         * @param {string} username Username of user to update
         * @param {boolean} setActive Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser: async (username: string, setActive: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('activateUser', 'username', username)
            // verify required parameter 'setActive' is not null or undefined
            assertParamExists('activateUser', 'setActive', setActive)
            const localVarPath = `/users/{username}/active`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (setActive !== undefined) {
                localVarQueryParameter['setActive'] = setActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {NewUserParams} newUserParams New user params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (newUserParams: NewUserParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newUserParams' is not null or undefined
            assertParamExists('createUser', 'newUserParams', newUserParams)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newUserParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username Username of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUser', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user based on the auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users, including (possibly) sensitive information like password hashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login User
         * @param {LoginBody} loginParams Login params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginParams: LoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginParams' is not null or undefined
            assertParamExists('loginUser', 'loginParams', loginParams)
            const localVarPath = `/users/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for users by username
         * @param {string} search Partial username to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (search: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchUsers', 'search', search)
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update admin status of user
         * @param {string} username Username of user to update
         * @param {boolean} setAdmin Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserAdmin: async (username: string, setAdmin: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('setUserAdmin', 'username', username)
            // verify required parameter 'setAdmin' is not null or undefined
            assertParamExists('setUserAdmin', 'setAdmin', setAdmin)
            const localVarPath = `/users/{username}/admin`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (setAdmin !== undefined) {
                localVarQueryParameter['setAdmin'] = setAdmin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user password
         * @param {string} username Username of user to update
         * @param {PasswordUpdateParams} passwordUpdateParams Password update params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (username: string, passwordUpdateParams: PasswordUpdateParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserPassword', 'username', username)
            // verify required parameter 'passwordUpdateParams' is not null or undefined
            assertParamExists('updateUserPassword', 'passwordUpdateParams', passwordUpdateParams)
            const localVarPath = `/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update active status of user
         * @param {string} username Username of user to update
         * @param {boolean} setActive Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser(username, setActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.activateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user
         * @param {NewUserParams} newUserParams New user params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(newUserParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username Username of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the user based on the auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users, including (possibly) sensitive information like password hashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoArchive>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login User
         * @param {LoginBody} loginParams Login params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.logoutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for users by username
         * @param {string} search Partial username to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.searchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update admin status of user
         * @param {string} username Username of user to update
         * @param {boolean} setAdmin Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserAdmin(username, setAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.setUserAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user password
         * @param {string} username Username of user to update
         * @param {PasswordUpdateParams} passwordUpdateParams Password update params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(username, passwordUpdateParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Update active status of user
         * @param {string} username Username of user to update
         * @param {boolean} setActive Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.activateUser(username, setActive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {NewUserParams} newUserParams New user params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createUser(newUserParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username Username of user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the user based on the auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users, including (possibly) sensitive information like password hashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfoArchive>> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login User
         * @param {LoginBody} loginParams Login params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.loginUser(loginParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for users by username
         * @param {string} search Partial username to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(search: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInfo>> {
            return localVarFp.searchUsers(search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update admin status of user
         * @param {string} username Username of user to update
         * @param {boolean} setAdmin Target admin status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setUserAdmin(username, setAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user password
         * @param {string} username Username of user to update
         * @param {PasswordUpdateParams} passwordUpdateParams Password update params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserPassword(username, passwordUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Update active status of user
     * @param {string} username Username of user to update
     * @param {boolean} setActive Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public activateUser(username: string, setActive: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).activateUser(username, setActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {NewUserParams} newUserParams New user params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(newUserParams: NewUserParams, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(newUserParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} username Username of user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the user based on the auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users, including (possibly) sensitive information like password hashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login User
     * @param {LoginBody} loginParams Login params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public loginUser(loginParams: LoginBody, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).loginUser(loginParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logoutUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for users by username
     * @param {string} search Partial username to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsers(search: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsers(search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update admin status of user
     * @param {string} username Username of user to update
     * @param {boolean} setAdmin Target admin status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setUserAdmin(username: string, setAdmin: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).setUserAdmin(username, setAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user password
     * @param {string} username Username of user to update
     * @param {PasswordUpdateParams} passwordUpdateParams Password update params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(username: string, passwordUpdateParams: PasswordUpdateParams, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(username, passwordUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}



